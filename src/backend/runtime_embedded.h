// 自动生成的嵌入式运行时库
// 请勿手动编辑

"/* Runtime support functions for FLYUX mixed-type system */\n"
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <string.h>\n"
    "#include <math.h>\n"
    "\n"
    "/* Value type tags */\n"
    "#define VALUE_NUMBER 0\n"
    "#define VALUE_STRING 1\n"
    "#define VALUE_ARRAY 2\n"
    "#define VALUE_OBJECT 3\n"
    "#define VALUE_BOOL 4\n"
    "#define VALUE_NULL 5\n"
    "\n"
    "/* Value structure */\n"
    "typedef struct {\n"
    "    int type;\n"
    "    union {\n"
    "        double number;\n"
    "        char *string;\n"
    "        void *pointer;\n"
    "    } data;\n"
    "} Value;\n"
    "\n"
    "/* Box a number into a Value */\n"
    "Value* box_number(double num) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_NUMBER;\n"
    "    v->data.number = num;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box a string into a Value */\n"
    "Value* box_string(char *str) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_STRING;\n"
    "    v->data.string = str;  // 不复制，直接使用全局常量\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box a boolean into a Value */\n"
    "Value* box_bool(int b) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_BOOL;\n"
    "    v->data.number = b ? 1.0 : 0.0;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box null */\n"
    "Value* box_null() {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_NULL;\n"
    "    v->data.number = 0.0;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box an array */\n"
    "Value* box_array(void *array_ptr, long size) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_ARRAY;\n"
    "    v->data.pointer = array_ptr;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Unbox to number (with type coercion) */\n"
    "double unbox_number(Value *v) {\n"
    "    if (!v) return 0.0;\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return v->data.number;\n"
    "        case VALUE_STRING:\n"
    "            // 尝试解析字符串为数字\n"
    "            if (v->data.string) {\n"
    "                double result = 0.0;\n"
    "                sscanf(v->data.string, \"%lf\", &result);\n"
    "                return result;\n"
    "            }\n"
    "            return 0.0;\n"
    "        case VALUE_NULL:\n"
    "            return 0.0;\n"
    "        default:\n"
    "            return 0.0;\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Unbox to string (with type coercion) */\n"
    "char* unbox_string(Value *v) {\n"
    "    if (!v) return \"(null)\";\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_STRING:\n"
    "            return v->data.string ? v->data.string : \"(empty)\";\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL: {\n"
    "            char *buf = (char*)malloc(32);\n"
    "            snprintf(buf, 32, \"%g\", v->data.number);\n"
    "            return buf;\n"
    "        }\n"
    "        case VALUE_NULL:\n"
    "            return \"null\";\n"
    "        default:\n"
    "            return \"(object)\";\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Check if value is truthy */\n"
    "int value_is_truthy(Value *v) {\n"
    "    if (!v) return 0;\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return v->data.number != 0.0;\n"
    "        case VALUE_STRING:\n"
    "            return v->data.string && v->data.string[0] != '\\0';\n"
    "        case VALUE_NULL:\n"
    "            return 0;\n"
    "        default:\n"
    "            return 1;  // objects/arrays are truthy\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Print a value (for debugging) */\n"
    "void value_print(Value *v) {\n"
    "    if (!v) {\n"
    "        printf(\"(null)\\n\");\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "            printf(\"%g\\n\", v->data.number);\n"
    "            break;\n"
    "        case VALUE_STRING:\n"
    "            printf(\"%s\\n\", v->data.string ? v->data.string : \"(empty)\");\n"
    "            break;\n"
    "        case VALUE_BOOL:\n"
    "            printf(\"%s\\n\", v->data.number != 0.0 ? \"true\" : \"false\");\n"
    "            break;\n"
    "        case VALUE_NULL:\n"
    "            printf(\"null\\n\");\n"
    "            break;\n"
    "        default:\n"
    "            printf(\"[object]\\n\");\n"
    "            break;\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Get type of value as string */\n"
    "char* value_typeof(Value *v) {\n"
    "    if (!v) return \"undefined\";\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER: return \"number\";\n"
    "        case VALUE_STRING: return \"string\";\n"
    "        case VALUE_BOOL: return \"boolean\";\n"
    "        case VALUE_NULL: return \"null\";\n"
    "        case VALUE_ARRAY: return \"array\";\n"
    "        case VALUE_OBJECT: return \"object\";\n"
    "        default: return \"unknown\";\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Value arithmetic operations */\n"
    "Value* value_add(Value *a, Value *b) {\n"
    "    // String concatenation\n"
    "    if (a->type == VALUE_STRING || b->type == VALUE_STRING) {\n"
    "        char *sa = unbox_string(a);\n"
    "        char *sb = unbox_string(b);\n"
    "        size_t len = strlen(sa) + strlen(sb) + 1;\n"
    "        char *result = (char*)malloc(len);\n"
    "        strcpy(result, sa);\n"
    "        strcat(result, sb);\n"
    "        return box_string(result);\n"
    "    }\n"
    "    \n"
    "    // Numeric addition\n"
    "    double na = unbox_number(a);\n"
    "    double nb = unbox_number(b);\n"
    "    return box_number(na + nb);\n"
    "}\n"
    "\n"
    "Value* value_subtract(Value *a, Value *b) {\n"
    "    return box_number(unbox_number(a) - unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_multiply(Value *a, Value *b) {\n"
    "    return box_number(unbox_number(a) * unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_divide(Value *a, Value *b) {\n"
    "    double divisor = unbox_number(b);\n"
    "    if (divisor == 0.0) return box_number(INFINITY);\n"
    "    return box_number(unbox_number(a) / divisor);\n"
    "}\n"
    "\n"
    "/* Value comparison */\n"
    "Value* value_equals(Value *a, Value *b) {\n"
    "    if (!a || !b) return box_bool(a == b);\n"
    "    if (a->type != b->type) {\n"
    "        // Type coercion comparison\n"
    "        return box_bool(unbox_number(a) == unbox_number(b));\n"
    "    }\n"
    "    \n"
    "    switch (a->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return box_bool(a->data.number == b->data.number);\n"
    "        case VALUE_STRING:\n"
    "            if (!a->data.string || !b->data.string)\n"
    "                return box_bool(a->data.string == b->data.string);\n"
    "            return box_bool(strcmp(a->data.string, b->data.string) == 0);\n"
    "        default:\n"
    "            return box_bool(a == b);  // reference equality\n"
    "    }\n"
    "}\n"
    "\n"
    "Value* value_less_than(Value *a, Value *b) {\n"
    "    return box_bool(unbox_number(a) < unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_greater_than(Value *a, Value *b) {\n"
    "    return box_bool(unbox_number(a) > unbox_number(b));\n"
    "}\n"
    "\n"
    "/* Array/Object index access - runtime version */\n"
    "Value* value_index(Value *obj, Value *index) {\n"
    "    if (!obj) return box_null();\n"
    "    \n"
    "    // For arrays stored as pointers\n"
    "    if (obj->type == VALUE_ARRAY && obj->data.pointer) {\n"
    "        int idx = (int)unbox_number(index);\n"
    "        Value **array = (Value **)obj->data.pointer;\n"
    "        // Note: no bounds checking for now\n"
    "        return array[idx];\n"
    "    }\n"
    "    \n"
    "    return box_null();\n"
    "}\n"
    "\n"
    "/* Free a value */\n"
    "void value_free(Value *v) {\n"
    "    if (v) {\n"
    "        // Note: we don't free strings as they might be global constants\n"
    "        free(v);\n"
    "    }\n"
    "}\n"
    ""
