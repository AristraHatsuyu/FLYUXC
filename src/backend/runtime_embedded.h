// 自动生成的嵌入式运行时库
// 请勿手动编辑

"/* Runtime support functions for FLYUX mixed-type system */\n"
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <string.h>\n"
    "#include <math.h>\n"
    "\n"
    "/* Value type tags */\n"
    "#define VALUE_NUMBER 0\n"
    "#define VALUE_STRING 1\n"
    "#define VALUE_ARRAY 2\n"
    "#define VALUE_OBJECT 3\n"
    "#define VALUE_BOOL 4\n"
    "#define VALUE_NULL 5\n"
    "\n"
    "/* Value structure */\n"
    "typedef struct {\n"
    "    int type;           /* 当前值的实际类型 */\n"
    "    int declared_type;  /* 变量的声明类型（用于类型注解）*/\n"
    "    union {\n"
    "        double number;\n"
    "        char *string;\n"
    "        void *pointer;\n"
    "    } data;\n"
    "    long array_size;    /* 数组大小（仅当type==VALUE_ARRAY时有效）*/\n"
    "} Value;\n"
    "\n"
    "/* Box a number into a Value */\n"
    "Value* box_number(double num) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_NUMBER;\n"
    "    v->declared_type = VALUE_NUMBER;\n"
    "    v->data.number = num;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box a string into a Value */\n"
    "Value* box_string(char *str) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_STRING;\n"
    "    v->declared_type = VALUE_STRING;\n"
    "    v->data.string = str;  // 不复制，直接使用全局常量\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box a boolean into a Value */\n"
    "Value* box_bool(int b) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_BOOL;\n"
    "    v->declared_type = VALUE_BOOL;\n"
    "    v->data.number = b ? 1.0 : 0.0;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box null */\n"
    "Value* box_null() {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_NULL;\n"
    "    v->declared_type = VALUE_NULL;\n"
    "    v->data.number = 0.0;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Box null with declared type - for typed variables */\n"
    "Value* box_null_typed(int decl_type) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_NULL;\n"
    "    v->declared_type = decl_type;\n"
    "    v->data.number = 0.0;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Create null preserving declared_type from existing value */\n"
    "Value* box_null_preserve_type(Value *old_val) {\n"
    "    if (!old_val) return box_null();\n"
    "    return box_null_typed(old_val->declared_type);\n"
    "}\n"
    "\n"
    "/* Box an array */\n"
    "Value* box_array(void *array_ptr, long size) {\n"
    "    Value *v = (Value*)malloc(sizeof(Value));\n"
    "    v->type = VALUE_ARRAY;\n"
    "    v->declared_type = VALUE_ARRAY;\n"
    "    v->data.pointer = array_ptr;\n"
    "    v->array_size = size;\n"
    "    return v;\n"
    "}\n"
    "\n"
    "/* Unbox to number (with type coercion) */\n"
    "double unbox_number(Value *v) {\n"
    "    if (!v) return 0.0;\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return v->data.number;\n"
    "        case VALUE_STRING:\n"
    "            // 尝试解析字符串为数字\n"
    "            if (v->data.string) {\n"
    "                double result = 0.0;\n"
    "                sscanf(v->data.string, \"%lf\", &result);\n"
    "                return result;\n"
    "            }\n"
    "            return 0.0;\n"
    "        case VALUE_NULL:\n"
    "            return 0.0;\n"
    "        default:\n"
    "            return 0.0;\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Unbox to string (with type coercion) */\n"
    "char* unbox_string(Value *v) {\n"
    "    if (!v) return \"(null)\";\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_STRING:\n"
    "            return v->data.string ? v->data.string : \"(empty)\";\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL: {\n"
    "            char *buf = (char*)malloc(32);\n"
    "            snprintf(buf, 32, \"%g\", v->data.number);\n"
    "            return buf;\n"
    "        }\n"
    "        case VALUE_NULL:\n"
    "            return \"null\";\n"
    "        default:\n"
    "            return \"(object)\";\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Check if value is truthy */\n"
    "int value_is_truthy(Value *v) {\n"
    "    if (!v) return 0;\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return v->data.number != 0.0;\n"
    "        case VALUE_STRING:\n"
    "            return v->data.string && v->data.string[0] != '\\0';\n"
    "        case VALUE_NULL:\n"
    "            return 0;\n"
    "        default:\n"
    "            return 1;  // objects/arrays are truthy\n"
    "    }\n"
    "}\n"
    "\n"
    "/* \u9012\u5f52\u6253\u5370\u6570\u7ec4\u5185\u5bb9\u4e3aJSON\u683c\u5f0f */\n"
    "static void print_array_json(Value **arr, long size) {\n"
    "    printf(\"[\");\n"
    "    for (long i = 0; i < size; i++) {\n"
    "        if (i > 0) printf(\",\");\n"
    "        if (!arr[i]) {\n"
    "            printf(\"null\");\n"
    "        } else {\n"
    "            switch (arr[i]->type) {\n"
    "                case VALUE_NUMBER:\n"
    "                    printf(\"%g\", arr[i]->data.number);\n"
    "                    break;\n"
    "                case VALUE_STRING:\n"
    "                    printf(\"\\\"%s\\\"\", arr[i]->data.string);\n"
    "                    break;\n"
    "                case VALUE_BOOL:\n"
    "                    printf(\"%s\", arr[i]->data.number != 0 ? \"true\" : \"false\");\n"
    "                    break;\n"
    "                case VALUE_NULL:\n"
    "                    printf(\"null\");\n"
    "                    break;\n"
    "                case VALUE_ARRAY: {\n"
    "                    Value **nested = (Value **)arr[i]->data.pointer;\n"
    "                    print_array_json(nested, arr[i]->array_size);\n"
    "                    break;\n"
    "                }\n"
    "                case VALUE_OBJECT:\n"
    "                    printf(\"{...}\");\n"
    "                    break;\n"
    "                default:\n"
    "                    printf(\"null\");\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "    printf(\"]\");\n"
    "}\n"
    "\n"
    "/* Print a value */\n"
    "void value_print(Value *v) {\n"
    "    if (!v) {\n"
    "        printf(\"<undef>\");\n"
    "        return;\n"
    "    }\n"
    "    \n"
    "    switch (v->type) {\n"
    "        case VALUE_NUMBER:\n"
    "            printf(\"%g\", v->data.number);\n"
    "            break;\n"
    "        case VALUE_STRING:\n"
    "            printf(\"%s\", v->data.string);\n"
    "            break;\n"
    "        case VALUE_BOOL:\n"
    "            printf(\"%s\", v->data.number != 0 ? \"true\" : \"false\");\n"
    "            break;\n"
    "        case VALUE_NULL:\n"
    "            printf(\"<null>\");\n"
    "            break;\n"
    "        case VALUE_ARRAY: {\n"
    "            Value **arr = (Value **)v->data.pointer;\n"
    "            if (!arr || v->array_size == 0) {\n"
    "                printf(\"[]\");\n"
    "            } else {\n"
    "                print_array_json(arr, v->array_size);\n"
    "            }\n"
    "            break;\n"
    "        }\n"
    "        case VALUE_OBJECT:\n"
    "            printf(\"{...}\");\n"
    "            break;\n"
    "        default:\n"
    "            printf(\"<unknown>\");\n"
    "            break;\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Print value with newline */\n"
    "void value_println(Value *v) {\n"
    "    value_print(v);\n"
    "    printf(\"\\n\");\n"
    "}\n"
    "\n"
    "/* Get type of value as string */\n"
    "char* value_typeof(Value *v) {\n"
    "    if (!v) return \"undef\";\n"
    "    \n"
    "    /* 返回声明类型而不是实际类型 */\n"
    "    switch (v->declared_type) {\n"
    "        case VALUE_NUMBER: return \"num\";\n"
    "        case VALUE_STRING: return \"str\";\n"
    "        case VALUE_BOOL: return \"bl\";\n"
    "        case VALUE_NULL: return \"null\";\n"
    "        case VALUE_ARRAY: return \"arr\";\n"
    "        case VALUE_OBJECT: return \"obj\";\n"
    "        default: return \"unknown\";\n"
    "    }\n"
    "}\n"
    "\n"
    "/* Value arithmetic operations */\n"
    "Value* value_add(Value *a, Value *b) {\n"
    "    // String concatenation\n"
    "    if (a->type == VALUE_STRING || b->type == VALUE_STRING) {\n"
    "        char *sa = unbox_string(a);\n"
    "        char *sb = unbox_string(b);\n"
    "        size_t len = strlen(sa) + strlen(sb) + 1;\n"
    "        char *result = (char*)malloc(len);\n"
    "        strcpy(result, sa);\n"
    "        strcat(result, sb);\n"
    "        return box_string(result);\n"
    "    }\n"
    "    \n"
    "    // Numeric addition\n"
    "    double na = unbox_number(a);\n"
    "    double nb = unbox_number(b);\n"
    "    return box_number(na + nb);\n"
    "}\n"
    "\n"
    "Value* value_subtract(Value *a, Value *b) {\n"
    "    return box_number(unbox_number(a) - unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_multiply(Value *a, Value *b) {\n"
    "    return box_number(unbox_number(a) * unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_divide(Value *a, Value *b) {\n"
    "    double divisor = unbox_number(b);\n"
    "    if (divisor == 0.0) return box_number(INFINITY);\n"
    "    return box_number(unbox_number(a) / divisor);\n"
    "}\n"
    "\n"
    "Value* value_power(Value *a, Value *b) {\n"
    "    return box_number(pow(unbox_number(a), unbox_number(b)));\n"
    "}\n"
    "\n"
    "/* Value comparison */\n"
    "Value* value_equals(Value *a, Value *b) {\n"
    "    if (!a || !b) return box_bool(a == b);\n"
    "    if (a->type != b->type) {\n"
    "        // Type coercion comparison\n"
    "        return box_bool(unbox_number(a) == unbox_number(b));\n"
    "    }\n"
    "    \n"
    "    switch (a->type) {\n"
    "        case VALUE_NUMBER:\n"
    "        case VALUE_BOOL:\n"
    "            return box_bool(a->data.number == b->data.number);\n"
    "        case VALUE_STRING:\n"
    "            if (!a->data.string || !b->data.string)\n"
    "                return box_bool(a->data.string == b->data.string);\n"
    "            return box_bool(strcmp(a->data.string, b->data.string) == 0);\n"
    "        default:\n"
    "            return box_bool(a == b);  // reference equality\n"
    "    }\n"
    "}\n"
    "\n"
    "Value* value_less_than(Value *a, Value *b) {\n"
    "    return box_bool(unbox_number(a) < unbox_number(b));\n"
    "}\n"
    "\n"
    "Value* value_greater_than(Value *a, Value *b) {\n"
    "    return box_bool(unbox_number(a) > unbox_number(b));\n"
    "}\n"
    "\n"
    "/* Array/Object index access - runtime version */\n"
    "Value* value_index(Value *obj, Value *index) {\n"
    "    if (!obj) return box_null();\n"
    "    \n"
    "    // For arrays stored as pointers\n"
    "    if (obj->type == VALUE_ARRAY && obj->data.pointer) {\n"
    "        int idx = (int)unbox_number(index);\n"
    "        Value **array = (Value **)obj->data.pointer;\n"
    "        // Note: no bounds checking for now\n"
    "        return array[idx];\n"
    "    }\n"
    "    \n"
    "    return box_null();\n"
    "}\n"
    "\n"
    "/* Free a value */\n"
    "void value_free(Value *v) {\n"
    "    if (v) {\n"
    "        // Note: we don't free strings as they might be global constants\n"
    "        free(v);\n"
    "    }\n"
    "}\n"
    ""
