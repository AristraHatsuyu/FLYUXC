#include "flyuxc/lexer.h"
#include "flyuxc/normalize.h"

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* ========== 小工具 ========== */

static int is_space_c(int c) {
    return c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '\f' || c == '\v';
}

/* 标识符起始：字母 / _ / 非 ASCII 字节（emoji 之类） */
static int is_ident_start(unsigned char c) {
    return (c == '_') || isalpha(c) || (c >= 0x80);
}

/* 标识符中间：字母 / 数字 / _ / 非 ASCII */
static int is_ident_char(unsigned char c) {
    return (c == '_') || isalnum(c) || (c >= 0x80);
}

/* 简单的 strndup */
static char* str_dup_n(const char* s, size_t len) {
    char* out = (char*)malloc(len + 1);
    if (!out) return NULL;
    memcpy(out, s, len);
    out[len] = '\0';
    return out;
}

/* 动态数组扩容 */
static int ensure_token_capacity(Token** arr, size_t* cap, size_t needed) {
    if (*cap >= needed) return 1;
    size_t new_cap = (*cap == 0) ? 32 : (*cap * 2);
    while (new_cap < needed) new_cap *= 2;
    Token* p = (Token*)realloc(*arr, new_cap * sizeof(Token));
    if (!p) return 0;
    *arr = p;
    *cap = new_cap;
    return 1;
}

/* ===== 内置函数表 ===== */
/* 后续可以随便往这里加内置函数名 */
static const char* BUILTIN_FUNC_TABLE[] = {
    "print",
    "length",
    NULL
};

static int is_builtin_func_name(const char* name) {
    for (int i = 0; BUILTIN_FUNC_TABLE[i] != NULL; i++) {
        if (strcmp(name, BUILTIN_FUNC_TABLE[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

/* 关键字 / 类型 / 布尔字面量检查 */
static TokenKind classify_identifier(const char* lexeme) {
    /* 关键字 */
    if (strcmp(lexeme, "if") == 0)   return TK_KW_IF;

    /* 类型 */
    if (strcmp(lexeme, "num") == 0)  return TK_TYPE_NUM;
    if (strcmp(lexeme, "str") == 0)  return TK_TYPE_STR;
    if (strcmp(lexeme, "bl") == 0)   return TK_TYPE_BL;
    if (strcmp(lexeme, "obj") == 0)  return TK_TYPE_OBJ;
    if (strcmp(lexeme, "func") == 0) return TK_TYPE_FUNC;

    /* 布尔 / 特殊值 */
    if (strcmp(lexeme, "true") == 0)  return TK_TRUE;
    if (strcmp(lexeme, "false") == 0) return TK_FALSE;
    if (strcmp(lexeme, "null") == 0)  return TK_NULL;
    if (strcmp(lexeme, "undef") == 0) return TK_UNDEF;

    /* 内置函数 */
    if (is_builtin_func_name(lexeme)) return TK_BUILTIN_FUNC;

    return TK_IDENT;
}

/* token kind -> 调试用名字 */
static const char* token_kind_name(TokenKind kind) {
    switch (kind) {
        case TK_ERROR:          return "ERROR";
        case TK_IDENT:          return "IDENT";
        case TK_BUILTIN_FUNC:   return "BUILTIN_FUNC";
        case TK_NUM:            return "NUM";
        case TK_STRING:         return "STRING";

        case TK_COLON:          return "COLON";
        case TK_SEMI:           return "SEMI";
        case TK_COMMA:          return "COMMA";
        case TK_DOT:            return "DOT";
        case TK_DOT_CHAIN:      return "DOT_CHAIN";
        case TK_L_PAREN:        return "L_PAREN";
        case TK_R_PAREN:        return "R_PAREN";
        case TK_L_BRACE:        return "L_BRACE";
        case TK_R_BRACE:        return "R_BRACE";
        case TK_L_BRACKET:      return "L_BRACKET";
        case TK_R_BRACKET:      return "R_BRACKET";

        case TK_ASSIGN:         return "ASSIGN";
        case TK_DEFINE:         return "DEFINE";
        case TK_FUNC_TYPE_START:return "FUNC_TYPE_START";
        case TK_FUNC_TYPE_END:  return "FUNC_TYPE_END";

        case TK_PLUS:           return "PLUS";
        case TK_MINUS:          return "MINUS";
        case TK_STAR:           return "STAR";
        case TK_SLASH:          return "SLASH";
        case TK_PERCENT:        return "PERCENT";

        case TK_LT:             return "LT";
        case TK_GT:             return "GT";
        case TK_LE:             return "LE";
        case TK_GE:             return "GE";
        case TK_EQ_EQ:          return "EQ_EQ";
        case TK_BANG:           return "BANG";
        case TK_BANG_EQ:        return "BANG_EQ";
        case TK_AND_AND:        return "AND_AND";
        case TK_OR_OR:          return "OR_OR";

        case TK_KW_IF:          return "KW_IF";
        case TK_KW_LOOP:        return "KW_LOOP";
        case TK_KW_RETURN:      return "KW_RETURN";

        case TK_TYPE_NUM:       return "TYPE_NUM";
        case TK_TYPE_STR:       return "TYPE_STR";
        case TK_TYPE_BL:        return "TYPE_BL";
        case TK_TYPE_OBJ:       return "TYPE_OBJ";
        case TK_TYPE_FUNC:      return "TYPE_FUNC";

        case TK_TRUE:           return "TRUE";
        case TK_FALSE:          return "FALSE";
        case TK_NULL:           return "NULL";
        case TK_UNDEF:          return "UNDEF";

        case TK_EOF:            return "EOF";
        default:                return "UNKNOWN";
    }
}

/* 生成错误信息 */
static char* make_unexpected_char_msg(char ch) {
    char buf[64];
    snprintf(buf, sizeof(buf), "Unexpected character: 0x%02X", (unsigned char)ch);
    return str_dup_n(buf, strlen(buf));
}

/* 添加一个 token */
static int emit_token(Token** tokens,
                      size_t* count,
                      size_t* cap,
                      TokenKind kind,
                      const char* lexeme_start,
                      size_t lexeme_len,
                      int line,
                      int column,
                      const SourceLocation* source_map,
                      size_t start_offset,
                      size_t end_offset) {
    if (!ensure_token_capacity(tokens, cap, *count + 1)) {
        return 0;
    }
    Token* t = &(*tokens)[*count];
    t->kind = kind;
    t->lexeme = str_dup_n(lexeme_start, lexeme_len);
    if (!t->lexeme) return 0;
    t->line = line;
    t->column = column;
    
    // 设置原始源码位置
    if (source_map && start_offset < end_offset) {
        t->orig_line_start = source_map[start_offset].orig_line;
        t->orig_column_start = source_map[start_offset].orig_column;
        t->orig_line_end = source_map[end_offset - 1].orig_line;
        t->orig_column_end = source_map[end_offset - 1].orig_column + 
                             source_map[end_offset - 1].orig_length - 1;
    } else {
        // 默认值
        t->orig_line_start = line;
        t->orig_column_start = column;
        t->orig_line_end = line;
        t->orig_column_end = column + (int)lexeme_len - 1;
    }
    
    (*count)++;
    return 1;
}

/* ========== 主词法分析 ========== */

LexerResult lexer_tokenize(const char* source,
                          const SourceLocation* source_map,
                          size_t source_map_size) {
    LexerResult result;
    result.tokens = NULL;
    result.count = 0;
    result.error_msg = NULL;
    result.error_code = 0;

    if (!source) {
        result.error_code = -1;
        result.error_msg = str_dup_n("source is NULL", strlen("source is NULL"));
        return result;
    }

    size_t len = strlen(source);
    size_t cap = 0;
    Token* tokens = NULL;

    size_t i = 0;
    int line = 1;
    int col  = 1;

    while (i < len) {
        char c = source[i];

        /* 跳过空白 */
        if (is_space_c((unsigned char)c)) {
            if (c == '\n') {
                line++;
                col = 1;
            } else {
                col++;
            }
            i++;
            continue;
        }

        int start_line = line;
        int start_col  = col;
        size_t start_offset = i;

        /* L> / R> 作为关键字 */
        if (c == 'L' && i + 1 < len && source[i + 1] == '>') {
            if (!emit_token(&tokens, &result.count, &cap,
                            TK_KW_LOOP, source + i, 2, start_line, start_col,
                            source_map, start_offset, i + 2)) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }
            i += 2;
            col += 2;
            continue;
        }

        if (c == 'R' && i + 1 < len && source[i + 1] == '>') {
            if (!emit_token(&tokens, &result.count, &cap,
                            TK_KW_RETURN, source + i, 2, start_line, start_col,
                            source_map, start_offset, i + 2)) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }
            i += 2;
            col += 2;
            continue;
        }

        /* 标识符 / 关键字 / 内置函数 / 类型名 */
        if (is_ident_start((unsigned char)c)) {
            size_t start = i;
            i++;
            col++;
            while (i < len && is_ident_char((unsigned char)source[i])) {
                i++;
                col++;
            }
            size_t ident_len = i - start;
            char* lexeme = str_dup_n(source + start, ident_len);
            if (!lexeme) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }

            TokenKind kind = classify_identifier(lexeme);

            /* emit_token 会自己再复制一份 lexeme，这里这份临时的要先 free 掉 */
            free(lexeme);
            if (!emit_token(&tokens, &result.count, &cap,
                            kind, source + start, ident_len, start_line, start_col)) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }
            continue;
        }

        /* 数字常量（目前只支持整数） */
        if (isdigit((unsigned char)c)) {
            size_t start = i;
            i++;
            col++;
            while (i < len && isdigit((unsigned char)source[i])) {
                i++;
                col++;
            }
            size_t num_len = i - start;
            if (!emit_token(&tokens, &result.count, &cap,
                            TK_NUM, source + start, num_len, start_line, start_col)) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }
            continue;
        }

        /* 字符串字面量：支持 "..." 或 '...'，简单跳过，内部不做转义 */
        if (c == '"' || c == '\'') {
            char quote = c;
            size_t start = i;
            i++;
            col++;
            while (i < len && source[i] != quote) {
                if (source[i] == '\n') {
                    line++;
                    col = 1;
                    i++;
                } else if (source[i] == '\\' && (i + 1) < len) {
                    /* 简单跳过转义对 */
                    i += 2;
                    col += 2;
                } else {
                    i++;
                    col++;
                }
            }
            if (i < len && source[i] == quote) {
                i++;
                col++;
            } else {
                /* 未闭合的字符串 */
                result.error_code = 1;
                result.error_msg = str_dup_n("Unterminated string literal", strlen("Unterminated string literal"));
                goto fail;
            }

            size_t str_len = i - start;
            if (!emit_token(&tokens, &result.count, &cap,
                            TK_STRING, source + start, str_len, start_line, start_col)) {
                result.error_code = -1;
                result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                goto fail;
            }
            continue;
        }

        /* 操作符 & 标点 */

        /* . 或 .> */
        if (c == '.') {
            if (i + 1 < len && source[i + 1] == '>') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_DOT_CHAIN, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_DOT, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* : / := / :< */
        if (c == ':') {
            if (i + 1 < len && source[i + 1] == '=') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_DEFINE, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else if (i + 1 < len && source[i + 1] == '<') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_FUNC_TYPE_START, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_COLON, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* & / && */
        if (c == '&') {
            if (i + 1 < len && source[i + 1] == '&') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_AND_AND, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                /* 单独 & 暂时当成错误或保留 */
                result.error_code = 1;
                result.error_msg = make_unexpected_char_msg(c);
                goto fail;
            }
            continue;
        }

        /* | / || */
        if (c == '|') {
            if (i + 1 < len && source[i + 1] == '|') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_OR_OR, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                result.error_code = 1;
                result.error_msg = make_unexpected_char_msg(c);
                goto fail;
            }
            continue;
        }

        /* ! / != */
        if (c == '!') {
            if (i + 1 < len && source[i + 1] == '=') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_BANG_EQ, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_BANG, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* = / == */
        if (c == '=') {
            if (i + 1 < len && source[i + 1] == '=') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_EQ_EQ, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_ASSIGN, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* < / <= */
        if (c == '<') {
            if (i + 1 < len && source[i + 1] == '=') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_LE, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_LT, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* > / >=（这里 >= 默认作为 FUNC_TYPE_END；如果以后要区分 GE，可以再增加状态机） */
        if (c == '>') {
            if (i + 1 < len && source[i + 1] == '=') {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_FUNC_TYPE_END, source + i, 2, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i += 2;
                col += 2;
            } else {
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_GT, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++;
                col++;
            }
            continue;
        }

        /* + - * / % ; , () {} [] */
        switch (c) {
            case '+':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_PLUS, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '-':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_MINUS, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '*':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_STAR, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '/':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_SLASH, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '%':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_PERCENT, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case ';':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_SEMI, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case ',':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_COMMA, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '(':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_L_PAREN, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case ')':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_R_PAREN, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '{':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_L_BRACE, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '}':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_R_BRACE, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case '[':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_L_BRACKET, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            case ']':
                if (!emit_token(&tokens, &result.count, &cap,
                                TK_R_BRACKET, source + i, 1, start_line, start_col)) {
                    result.error_code = -1;
                    result.error_msg = str_dup_n("Memory allocation failed", strlen("Memory allocation failed"));
                    goto fail;
                }
                i++; col++;
                continue;
            default:
                break;
        }

        /* 未知字符 */
        result.error_code = 1;
        result.error_msg = make_unexpected_char_msg(c);
        goto fail;
    }

    /* 注意：不再生成 EOF token，语法结束完全靠 ';' 和 token 数组长度 */
    result.tokens = tokens;
    result.error_code = 0;
    result.error_msg = NULL;
    return result;

fail:
    if (tokens) {
        for (size_t k = 0; k < result.count; k++) {
            free(tokens[k].lexeme);
        }
        free(tokens);
    }
    result.tokens = NULL;
    result.count = 0;
    return result;
}

/* ========== 释放 / 打印 ========== */

void lexer_result_free(LexerResult* result) {
    if (!result) return;
    if (result->tokens) {
        for (size_t i = 0; i < result->count; i++) {
            free(result->tokens[i].lexeme);
        }
        free(result->tokens);
        result->tokens = NULL;
    }
    if (result->error_msg) {
        free(result->error_msg);
        result->error_msg = NULL;
    }
    result->count = 0;
    result->error_code = 0;
}

void lexer_print_tokens(const LexerResult* result, FILE* out) {
    if (!result || !out) return;
    for (size_t i = 0; i < result->count; i++) {
        const Token* t = &result->tokens[i];

        /* 现在不生成 EOF；即便将来生成，也不在调试输出里打印 EOF */
        if (t->kind == TK_EOF) {
            continue;
        }

        fprintf(out,
                "(%s) \"%s\" at %d:%d\n",
                token_kind_name(t->kind),
                t->lexeme ? t->lexeme : "",
                t->line,
                t->column);
    }
}
